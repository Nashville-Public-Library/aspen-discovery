<?php
require_once ROOT_DIR . '/sys/DB/DataObject.php';
require_once ROOT_DIR . '/sys/Events/EventType.php';
require_once ROOT_DIR . '/sys/Events/EventTypeLibrary.php';
require_once ROOT_DIR . '/sys/Events/EventTypeLocation.php';
require_once ROOT_DIR . '/sys/Events/EventEventField.php';
require_once ROOT_DIR . '/sys/Events/EventInstance.php';

class Event extends DataObject {
	public $__table = 'event';
	public $id;
	public $eventTypeId;
	public $locationId;
	public $sublocationId;
	public $title;
	public $description;
	public $cover;
	public $private;
	public $_typeFields = [];
	public $startDate;
	public $_startDateForList;
	public $startTime;
	public $eventLength;
	public $_endDate; //generated by start time + event length
	public $_endTime; //generated by start time + event length
	public $recurrenceOption;
	public $recurrenceInterval;
	public $recurrenceFrequency;
	public $weekDays;
	public $monthlyOption;
	public $monthDay;
	public $monthDate;
	public $monthOffset;
	public $endOption;
	public $recurrenceEnd;
	public $recurrenceCount;
	public $_dates; // Used to generate instances
	public $_instanceCount;
	public $_datesPreview;

	public $dateUpdated;
	public $deleted;




	public static function getObjectStructure($context = ''): array {
		global $configArray;
		$coverPath = $configArray['Site']['coverPath'];
		$eventTypes = EventType::getEventTypeList();
		$libraryList = Library::getLibraryList(!UserAccount::userHasPermission('Administer All Libraries'));
		$locationList = Location::getLocationList(!UserAccount::userHasPermission('Administer All Libraries') || UserAccount::userHasPermission('Administer Home Library Locations'));
		$structure = [
			'id' => [
				'property' => 'id',
				'type' => 'label',
				'label' => 'Id',
				'description' => 'The unique id',
			],
			'locationId' => [
				'property' => 'locationId',
				'type' => 'enum',
				'label' => 'Location',
				'description' => 'Location of the event',
				'required' => true,
				'values' => $locationList,
				'onchange' => 'return AspenDiscovery.Events.getEventTypesForLocation(this.value);',
			],
			'sublocationId' => [
				'property' => 'sublocationId',
				'type' => 'enum',
				'label' => 'Sublocation',
				'description' => 'Sublocation of the event',
				'values' => [],
				'hiddenByDefault' => true,
			],
			'eventTypeId' => [
				'property' => 'eventTypeId',
				'type' => 'enum',
				'label' => 'Event Type',
				'description' => 'The type of event',
				'required' => true,
				'values' => $eventTypes,
				'onchange' => "return AspenDiscovery.Events.getEventTypeFields(this.value);"
			],
			'title' => [
				'property' => 'title',
				'type' => 'text',
				'label' => 'Title',
				'description' => 'The title for this event',
			],
			'infoSection' => [
				'property' => 'infoSection',
				'type' => 'section',
				'label' => 'Event Information',
				'expandByDefault' => true,
				'properties' => [
					'description' => [
						'property' => 'description',
						'type' => 'textarea',
						'label' => 'Description',
						'description' => 'The description for this event',
					],
					'cover' => [
						'property' => 'cover',
						'type' => 'image',
						'label' => 'Cover',
						'maxWidth' => 280,
						'maxHeight' => 280,
						'description' => 'The cover for this event',
						'path' => "$coverPath/aspenEvents/",
						'hideInLists' => true,
					],
					'fieldSetFieldSection' => [
						'property' => 'fieldSetFieldSection',
						'type' => 'section',
						'label' => 'Fields for this Event Type',
						'hideInLists' => true,
						'expandByDefault' => true,
						'properties' => [],
					],
					'private' => [
						'property' => 'private',
						'type' => 'checkbox',
						'label' => 'Private?',
						'default' => false,
						'description' => 'Private events are limited to those with permission to view private events',
					],
				],
			],
			'startDateForList' => [
				'property' => 'startDateForList',
				'type' => 'date',
				'label' => 'Start Date',
				'readOnly' => true,
				'hiddenByDefault' => true,
			],
			'scheduleSection' => [
				'property' => 'scheduleSection',
				'type' => 'section',
				'label' => 'Event Scheduling',
				'expandByDefault' => true,
				'hiddenByDefault' => true,
				'properties' => [
					'startDate' => [
						'property' => 'startDate',
						'type' => 'hidden',
					],
					'startTime' => [
						'property' => 'startTime',
						'type' => 'hidden',
					],
					'eventLength' => [
						'property' => 'eventLength',
						'type' => 'hidden',
					],
					'endDate' => [
						'property' => 'endDate',
						'type' => 'hidden',
					],
					'endTime' => [
						'property' => 'endTime',
						'type' => 'hidden',
					],
					'recurrenceOption' => [
						'property' => 'recurrenceOption',
						'type' => 'hidden',
						'default' => 1,
					],
					'frequencySection' => [
						'property' => 'frequencySection',
						'type' => 'section',
						'label' => 'Event Frequency',
						'hiddenByDefault' => true,
						'properties' => [
							'recurrenceInterval' => [
								'property' => 'recurrenceInterval',
								'type' => 'hidden',
								'default' => 1,
							],
							'recurrenceFrequency' => [
								'property' => 'recurrenceFrequency',
								'type' => 'hidden',
								'default' => 1,
							]
						]
					],
					'weeklySection' => [
						'property' => 'weeklySection',
						'type' => 'section',
						'label' => 'Repeat Based on Week',
						'hiddenByDefault' => true,
						'properties' => [
							'weekDays' => [
								'property' => 'weekDays',
								'type' => 'hidden',
							],
						]
					],
					'monthlySection' => [
						'property' => 'monthlySection',
						'type' => 'section',
						'label' => 'Repeat Based on Month',
						'hiddenByDefault' => true,
						'properties' => [
							'monthlyOption' => [
								'property' => 'monthlyOption',
								'type' => 'hidden',
								'default' => 1
							],
							'monthDay' => [
								'property' => 'monthDay',
								'type' => 'hidden',
								'default' => 1,
							],
							'monthDate' => [
								'property' => 'monthDate',
								'type' => 'hidden',
							],
							'monthOffset' => [
								'property' => 'monthOffset',
								'type' => 'hidden',
							],
						]
					],
					'repeatEndsSection' => [
						'property' => 'repeatEndsSection',
						'type' => 'section',
						'label' => 'Repeat Ends',
						'hiddenByDefault' => true,
						'properties' => [
							'endOption' => [
								'property' => 'endOption',
								'type' => 'hidden',
								'default' => 1,
							],
							'recurrenceEnd' => [
								'property' => 'recurrenceEnd',
								'type' => 'hidden',
							],
							'recurrenceCount' => [
								'property' => 'recurrenceCount',
								'type' => 'hidden',
								'default' => 1,
							],
						],
					],
					'datesPreview' => [
						'property' => 'datesPreview',
						'type' => 'hidden',
					],
				],
			],
			'dates' => [
				'property' => 'dates',
				'type' => 'hidden',
				'hideInLists' => true,
			],
			'instanceCount' => [
				'property' => 'instanceCount',
				'type' => 'integer',
				'label' => 'Total Upcoming Events',
				'hiddenByDefault' => true,
				'readOnly' => true,
			],
			'dateUpdated' => [
				'property' => 'dateUpdated',
				'label' => 'Date Updated',
				'type' => 'integer',
				'hiddenByDefault' => true,
				'hideInLists' => true,
			]
		];
		// Add empty, hidden, readonly copies of all potential fields so that data can be added if they exist for any selected event type
		$eventFieldList = EventField::getEventFieldList();
		foreach ($eventFieldList as $fieldId => $field) {
			$structure['infoSection']['properties']['fieldSetFieldSection']['properties'][$fieldId] = [
				'property' => $fieldId,
				'label' => $field,
				'readOnly' => true,
				'type' => 'hidden',
			];
		}
		if ($context == 'addNew') {
			$structure['eventTypeId'] = [
				'property' => 'eventTypeId',
				'type' => 'enum',
				'label' => 'Event Type',
				'required' => true,
				'description' => 'The type of event',
				'placeholder' => 'Choose an event type',
				'values' => $eventTypes,
				'onchange' => "return AspenDiscovery.Events.getEventTypeFields(this.value);",
			];
			$structure['title']['hiddenByDefault'] = true;
			$structure['infoSection']['hiddenByDefault'] = true;
			$structure['infoSection']['properties']['description']['hiddenByDefault'] = true;
			$structure['infoSection']['properties']['cover']['hiddenByDefault'] = true;
			$structure['infoSection']['properties']['fieldSetFieldSection']['hiddenByDefault'] = true;
		} else {
			$structure['eventTypeId'] = [
				'property' => 'eventTypeId',
				'type' => 'enum',
				'label' => 'Event Type',
				'description' => 'The type of event',
				'values' => $eventTypes,
				'readOnly' => true,
			];
			$structure['locationId']['readOnly'] = true;
			$structure['scheduleSection']['properties'] = [
				'startDate' => [
					'property' => 'startDate',
					'type' => 'date',
					'label' => 'Event Date',
					'description' => 'The date this event starts',
					'onchange' => "return AspenDiscovery.Events.updateRecurrenceOptions(this.value);"
				],
				'startTime' => [
					'property' => 'startTime',
					'type' => 'time',
					'label' => 'Start Time',
					'description' => 'The time this event starts',
					'onchange' => 'return AspenDiscovery.Events.calculateEndTime();'
				],
				'eventLength' => [
					'property' => 'eventLength',
					'type' => 'integer',
					'label' => 'Event Length (Hours)',
					'description' => 'How long this event lasts',
					'note' => 'Default determined by Event Type',
					'onchange' => "return AspenDiscovery.Events.calculateEndTime();"
				],
				'endDate' => [
					'property' => 'endDate',
					'type' => 'date',
					'label' => 'End Date',
					'description' => 'The date this event ends',
					'note' => 'Automatically calculated based on Event Date, Start Time, and Event Length',
				],
				'endTime' => [
					'property' => 'endTime',
					'type' => 'time',
					'label' => 'End Time',
					'description' => 'The time this event ends',
					'note' => 'Automatically calculated based on Event Date, Start Time, and Event Length',
				],
				'recurrenceOption' => [
					'property' => 'recurrenceOption',
					'type' => 'enum',
					'label' => 'Repeat Options',
					'description' => 'How this event repeats',
					'values' => [
						'1' => 'Does not repeat',
						'2' => 'Daily',
						'3' => 'Weekly on this day', // Update option descriptions based on the start date
						'4' => 'Monthly on the same weekday',
						'5' => 'Annually on the same date',
						'6' => 'Every weekday (Monday - Friday)',
						'7' => 'Custom',
					],
					'onchange' => "return AspenDiscovery.Events.toggleRecurrenceSections(this.value);"
				],
				'frequencySection' => [
					'property' => 'frequencySection',
					'type' => 'section',
					'label' => 'Repeat Frequency',
					'properties' => [
						'recurrenceFrequency' => [
							'property' => 'recurrenceFrequency',
							'type' => 'enum',
							'label' => 'Repeat Frequency',
							'values' => [
								'1' => 'Daily',
								'2' => 'Weekly',
								'3' => 'Monthly',
								'4' => 'Annually on the same date',
							],
							'onchange' => "return AspenDiscovery.Events.toggleSectionsByFrequency(this.value);"
						],
						'recurrenceInterval' => [
							'property' => 'recurrenceInterval',
							'type' => 'integer',
							'label' => 'Repeat Interval',
							'note' => 'Repeats every [interval] days/weeks/months',
						],
					],
					'expandByDefault' => false,
					'hiddenByDefault' => true,
				],
				'weeklySection' => [
					'property' => 'weeklySection',
					'type' => 'section',
					'label' => 'Repeat Based on Week',
					'properties' => [
						'weekDays' => [
							'property' => 'weekDays',
							'type' => 'multiSelect',
							'listStyle' => 'checkbox',
							'label' => 'Day(s) to Repeat On',
							'values' => [
								'0' => 'Sunday',
								'1' => 'Monday',
								'2' => 'Tuesday',
								'3' => 'Wednesday',
								'4' => 'Thursday',
								'5' => 'Friday',
								'6' => 'Saturday',
							],
							'onchange' => "return AspenDiscovery.Events.calculateRecurrenceDates();",
						],
					],
					'hiddenByDefault' => true,
					'expandByDefault' => false,
				],
				'monthlySection' => [
					'property' => 'monthlySection',
					'type' => 'section',
					'label' => 'Repeat Based on Month',
					'properties' => [
						'monthlyOption' => [
							'property' => 'monthlyOption',
							'type' => 'enum',
							'label' => 'Monthly Repeat Options',
							'values' => [
								'1'	=> 'Repeat based on day of the week',
								'2'	=> 'Repeat based on date',
							],
							'onchange' => "return AspenDiscovery.Events.toggleMonthlyOptions(this.value);"
						],
						'weekNumber' => [
							'property' => 'weekNumber',
							'type' => 'enum',
							'label' => 'Week Number',
							'values' => [
								'1' => '1st',
								'2' => '2nd',
								'3' => '3rd',
								'4' => '4th',
								'5' => '5th',
								'-1' => 'Last',
							],
							'onchange' => "return AspenDiscovery.Events.calculateRecurrenceDates();",
						],
						'monthDay' => [
							'property' => 'monthDay',
							'type' => 'enum',
							'label' => 'Day to Repeat On',
							'values' => [
								'0' => 'Sunday',
								'1' => 'Monday',
								'2' => 'Tuesday',
								'3' => 'Wednesday',
								'4' => 'Thursday',
								'5' => 'Friday',
								'6' => 'Saturday',
							],
							'onchange' => "return AspenDiscovery.Events.calculateRecurrenceDates();",
						],
						'monthDate' => [
							'property' => 'monthDate',
							'type' => 'integer',
							'label' => 'Date to repeat on',
							'hiddenByDefault' => true,
							'min' => '-1',
							'max' => '31',
							'note' => 'Use -1 to repeat on the last day of the month',
							'onchange' => "return AspenDiscovery.Events.calculateRecurrenceDates();",
						],
						'monthOffset' => [
							'property' => 'monthOffset',
							'type' => 'integer',
							'label' => 'Offset',
							'default' => '0',
							'note' => 'Number of days to add before or after (use negative numbers for before)',
							'onchange' => "return AspenDiscovery.Events.calculateRecurrenceDates();",
						]
					],
					'hiddenByDefault' => true,
					'expandByDefault' => false,
				],
				'repeatEndsSection' => [
					'property' => 'repeatEndsSection',
					'type' => 'section',
					'label' => 'Repeat Ends',
					'hiddenByDefault' => true,
					'expandByDefault' => true,
					'properties' => [
						'endOption' => [
							'property' => 'endOption',
							'type' => 'enum',
							'label' => 'Repeat End Options',
							'values' => [
								'1'	=> 'Ends on a date',
								'2'	=> 'Ends after a specific number of events',
							],
							'onchange' => "return AspenDiscovery.Events.toggleEndOptions(this.value);"
						],
						'recurrenceEnd' => [
							'property' => 'recurrenceEnd',
							'type' => 'date',
							'label' => 'Ends After',
							'onchange' => "return AspenDiscovery.Events.calculateRecurrenceDates();"
						],
						'recurrenceCount' => [
							'property' => 'recurrenceCount',
							'type' => 'integer',
							'label' => 'Times to repeat',
							'hiddenByDefault' => true,
							'onchange' => "return AspenDiscovery.Events.calculateRecurrenceDates();"
						],
					],
				],
				'datesPreview' => [
					'property' => 'datesPreview',
					'type' => 'label',
					'label' => 'Date Preview',
					'note' => 'To update, change the scheduling options above',
					'readOnly' => true,
					'hiddenByDefault' => true,
				],
			];
			$structure['infoSection']['expandByDefault'] = false;
			$structure['scheduleSection']['hiddenByDefault'] = false;
		}
		return $structure;
	}

	public function update($context = '') {
		$this->dateUpdated = time();
		$ret = parent::update();
		if ($ret !== FALSE) {
			$this->saveLibraries();
			$this->saveLocations();
			$this->saveFields();
			$this->generateInstances();
		}
		return $ret;
	}

	public function insert($context = '') {
		if (empty($this->dateUpdated)) {
			$this->dateUpdated = time(); // Set to 0 for new events
		}
		$ret = parent::insert();
		if ($ret !== FALSE) {
			$this->saveLibraries();
			$this->saveLocations();
			$this->saveFields();
			$this->generateInstances();
		}
		return $ret;
	}

	function delete($useWhere = false) : int {
		if (!$useWhere) {
			$this->deleted = 1;
			$this->dateUpdated = time();
			$ret = parent::update();

			if ($ret) {
				$instance = new EventInstance();
				$instance->eventId = $this->id;
				$instance->find();
				while ($instance->fetch()) {
					$instance->delete(false);
				}
				return true;
			}
			return false;
		} else {
			return parent::delete($useWhere);
		}
	}

	public function __set($name, $value) {
		if ($name == 'libraries') {
			$this->setLibraries($value);
		} else if ($name == 'locations'){
			$this->setLocations($value);
		} else if (is_numeric($name)) {
			$this->setTypeField($name, $value);
		} else if ($name == 'startDateForList') {
			$this->_startDateForList = $this->startDate;
		} else if ($name == 'dates') {
			$this->setDates($value);
		} else if ($name == 'datesPreview') {
			$this->setDatesPreview($value);
		} else {
			parent::__set($name, $value);
		}
	}

	public function __get($name) {
		if ($name == 'libraries') {
			return $this->getLibraries();
		} else if ($name == 'locations') {
			return $this->getLocations();
		} else if (is_numeric($name)){
			return $this->getTypeField($name);
		} else if ($name == 'startDateForList') {
			return parent::__get('startDate');
		} else if ($name == 'dates') {
			return $this->getExistingDates();
		} else if ($name == 'instanceCount') {
			return $this->getInstanceCount();
		} else if ($name == 'datesPreview') {
			return $this->getDatesPreview();
		} else if ($name == 'endDate') {
			return $this->calculateEnd($name);
		} else if ($name == 'endTime') {
			return $this->calculateEnd($name);
		} else {
			return parent::__get($name);
		}
	}

	public function getNumericColumnNames(): array {
		return [
			'private',
			'eventLength',
			'recurrenceOption',
			'recurrenceCount',
			'recurrenceInterval',
			'recurrenceFrequency',
			'monthlyOptions',
			'monthDay',
			'monthDate',
			'monthOffset',
			'endOption',
			'dateUpdated'
		];
	}

	public function getAdditionalListActions(): array {
		$objectActions[] = [
			'text' => 'Edit Specific Dates',
			'url' => '/Events/EventInstances?objectAction=edit&id=' . $this->id,
		];

		return $objectActions;
	}

	public function setLibraries($value) {
		$this->_libraries = $value;
	}

	public function setLocations($value) {
		$this->_locations = $value;
	}

	public function getLibraries() {
		if (!isset($this->_libraries) && $this->id) {
			$this->_libraries = [];
			$library = new EventTypeLibrary();
			$library->eventTypeId = $this->id;
			$library->find();
			while ($library->fetch()) {
				$this->_libraries[$library->libraryId] = clone($library);
			}
		}
		return $this->_libraries;
	}

	public function getLocations() {
		if (!isset($this->_locations) && $this->id) {
			$this->_locations = [];
			$location = new EventTypeLocation();
			$location->eventTypeId = $this->id;
			$location->find();
			while ($location->fetch()) {
				$this->_locations[$location->locationId] = clone($location);
			}
		}
		return $this->_locations;
	}

	public function saveLibraries() {
		if (isset($this->_libraries) && is_array($this->_libraries)) {
			$this->clearLibraries();

			foreach ($this->_libraries as $library) {
				$eventTypeLibrary = new EventTypeLibrary();
				$eventTypeLibrary->libraryId = $library;
				$eventTypeLibrary->eventTypeId = $this->id;
				$eventTypeLibrary->update();
			}
			unset($this->_libraries);
		}
	}

	public function saveLocations() {
		if (isset($this->_locations) && is_array($this->_locations)) {
			$this->clearLocations();

			foreach ($this->_locations as $location) {
				$eventTypeLocation = new EventTypeLocation();
				$eventTypeLocation->locationId = $location;
				$eventTypeLocation->eventTypeId = $this->id;
				$eventTypeLocation->update();
			}
			unset($this->_locations);
		}
	}

	public function generateInstances() {
		// If event doesn't repeat and there is a start date, time and event length
		if (isset($this->startDate) && isset($this->startTime) && isset($this->eventLength)) {
			$todayDate = date('Y-m-d');
			$todayTime = date('H:i:s');
			if ($this->recurrenceOption == '1') {
				// Don't generate dates in the past
				if ($this->startDate > $todayDate || ($this->startDate == $todayDate && $this->startTime > $todayTime)) {
					$instance = new EventInstance();
					$instance->eventId = $this->id;
					$instance->find(true); // Update event if it already exists
					$instance->date = $this->startDate;
					$instance->time = $this->startTime;
					$instance->length = $this->eventLength;
					$instance->update();
				}
			} else { // If event does repeat and there are preview dates
				if ($this->_dates && is_array($this->_dates)) {
					if (in_array('dates', $this->_changedFields)) {
						// Should add more user options about which events to change
						$this->clearFutureInstances();
						foreach ($this->_dates as $date) {
							// Don't create instances in the past
							if ($date > $todayDate || ($date == $todayDate && $this->startTime > $todayTime)) {
								$instance = new EventInstance();
								$instance->eventId = $this->id;
								$instance->date = $date;
								$instance->time = $this->startTime;
								$instance->length = $this->eventLength;
								$instance->update();
							}
						}
					}
				}
			}
		}
	}

	private function clearFutureInstances() {
		$instance = new EventInstance();
		$instance->eventId = $this->id;
		$instance->find();
		$todayDate = date('Y-m-d');
		$todayTime = date('H:i:s');
		$instance->whereAdd("date > '$todayDate' OR (date = '$todayDate' and time > '$todayTime')");
		$instance->deleted = 1;
		while ($instance->fetch()) {
			$instance->update();
		}
	}


	private function clearLibraries() {
		//Unset existing library associations
		$eventTypeLibrary = new EventTypeLibrary();
		$eventTypeLibrary->eventTypeId = $this->id;
		$eventTypeLibrary->find();
		while ($eventTypeLibrary->fetch()){
			$eventTypeLibrary->delete(true);;
		}
	}

	private function clearLocations() {
		//Unset existing library associations
		$eventTypeLocation = new EventTypeLocation();
		$eventTypeLocation->eventTypeId = $this->id;
		$eventTypeLocation->find();
		while ($eventTypeLocation->fetch()){
			$eventTypeLocation->delete(true);
		}
	}

	public function setTypeField($fieldId, $value) {
		$this->_typeFields[$fieldId] = $value;
	}

	public function setDates ($value) {
		$value = explode(',', $value);
		$this->_dates = $value;
	}

	public function setDatesPreview($value) {
		$this->_datesPreview = $value;
	}

	public function getTypeField($fieldId) {
		if (!isset($this->_typeFields[$fieldId]) && $this->id) {
			$this->_typeFields[$fieldId] = '';
			$field = new EventEventField();
			$field->eventId = $this->id;
			$field->eventFieldId = $fieldId;
			if ($field->find(true)) {
				$this->_typeFields[$fieldId] = $field->value;
			}
		}
		return $this->_typeFields[$fieldId] ?? '';
	}

	public function getDatesPreview() {
		if (!isset($this->_dates) && $this->id) {
			$this->_datesPreview = '';
			$instance = new EventInstance();
			$instance->eventId = $this->id;
			$instance->find();
			while ($instance->fetch()) {
				$date = strtotime($instance->date);
				if ($date) {
					$this->_datesPreview .= date("l, F jS, Y", $date) . "; ";
				}
			}
		}
		return $this->_datesPreview ?? '';
	}

	public function getExistingDates() {
		if (!isset($this->_dates) && $this->id) {
			$this->_dates = [];
			$instance = new EventInstance();
			$instance->eventId = $this->id;
			$instance->find();
			while ($instance->fetch()) {
				$this->_dates[] = $instance->date;
			}
		}
		if (is_array($this->_dates)) {
			return implode(",", $this->_dates);
		} else {
			return $this->_dates;
		}
	}

	public function getInstanceCount() {
		if (!isset($this->_instanceCount) && $this->id) {
			$this->_instanceCount = '';
			$instance = new EventInstance();
			$instance->eventId = $this->id;
			$todayDate = date('Y-m-d');
			$todayTime = date('H:i:s');
			$instance->whereAdd("deleted = 0 AND date > '$todayDate' OR (date = '$todayDate' and time > '$todayTime')");
			$this->_instanceCount = $instance->count();
		}
		return $this->_instanceCount;
	}

	public function saveFields() {
		if (isset($this->_typeFields) && is_array($this->_typeFields)) {
			$this->clearFields();

			foreach ($this->_typeFields as $fieldId => $field) {
				$eventField = new EventEventField();
				$eventField->eventFieldId = $fieldId;
				$eventField->eventId = $this->id;
				if ($field == "on") { // Handle checkboxes
					$eventField->value = 1;
				} else {
					$eventField->value = $field;
				}
				$eventField->update();
			}
			unset($this->_typeFields);
		}
	}

	private function clearFields() {
		//Delete existing field associations
		$eventField = new EventEventField();
		$eventField->eventId = $this->id;
		$eventField->find();
		while ($eventField->fetch()){
			$eventField->delete(true);
		}
	}

	public function getEventType() {
		if (isset($this->eventTypeId)) {
			$eventType = new EventType();
			$eventType->id = $this->eventTypeId;
			if ($eventType->find(true)) {
				return $eventType;
			}
		}
	}

	public function calculateEnd($fieldName) {
		if (isset($this->startDate) && isset($this->startTime) && isset($this->eventLength)) {
			$dateTime = new \DateTime($this->startDate . ' ' . $this->startTime);
			$dateTime->modify('+' . $this->eventLength . ' hours');
			$endDate = $dateTime->format('Y-m-d');
			$endTime = $dateTime->format('H:i:s');
		}
		if ($fieldName == "endTime") {
			return $endTime;
		} else if ($fieldName == "endDate") {
			return $endDate;
		}
		return NULL;
	}

	public function updateStructureForEditingObject($structure) : array {
		if ($eventType = $this->getEventType()) {
			if (!empty($this->eventTypeId)) {
				if (empty($this->title)) {
					$this->title = $eventType->title;
				}
				if (!$eventType->titleCustomizable) {
					$this->title = $eventType->title;
					$structure['title']['readOnly'] = true;
				}
				if (empty($this->description)) {
					$this->description = $eventType->description;
				}
				if (!$eventType->descriptionCustomizable) {
					$this->description = $eventType->description;
					$structure['infoSection']['properties']['description']['readOnly'] = true;
				}
				if (empty($this->cover)) {
					$this->cover = $eventType->cover;
				}
				if (!$eventType->coverCustomizable) {
					$structure['infoSection']['properties']['cover']['readOnly'] = true;
					$this->cover = $eventType->cover;
				}
				if (empty($this->eventLength)) {
					$this->eventLength = $eventType->eventLength;
				}
				if (!$eventType->lengthCustomizable) {
					$structure['scheduleSection']['properties']['eventLength']['readOnly'] = true;
					$this->eventLength = $eventType->eventLength;
				}
				$structure['infoSection']['properties']['fieldSetFieldSection']['properties'] = $eventType->getFieldSetFields();
				// Update scheduling sections
				switch ($this->recurrenceOption) {
					case '2':
						// daily repeat
						$structure['scheduleSection']['properties']['frequencySection']['hiddenByDefault'] = false;
						$structure['scheduleSection']['properties']['repeatEndsSection']['hiddenByDefault'] = false;
						$structure['scheduleSection']['properties']['datesPreview']['hiddenByDefault'] = false;
						break;
					case '6': // every weekday - same as weekly
					case '3':
						// weekly repeats
						$structure['scheduleSection']['properties']['frequencySection']['hiddenByDefault'] = false;
						$structure['scheduleSection']['properties']['weeklySection']['hiddenByDefault'] = false;
						$structure['scheduleSection']['properties']['repeatEndsSection']['hiddenByDefault'] = false;
						$structure['scheduleSection']['properties']['datesPreview']['hiddenByDefault'] = false;
						break;
					case '4':
						// monthly repeats
						$structure['scheduleSection']['properties']['frequencySection']['hiddenByDefault'] = false;
						$structure['scheduleSection']['properties']['monthlySection']['hiddenByDefault'] = false;
						$structure['scheduleSection']['properties']['repeatEndsSection']['hiddenByDefault'] = false;
						$structure['scheduleSection']['properties']['datesPreview']['hiddenByDefault'] = false;
						break;
					case '5':
						// annual repeats
						$structure['scheduleSection']['properties']['frequencySection']['hiddenByDefault'] = false;
						$structure['scheduleSection']['properties']['repeatEndsSection']['hiddenByDefault'] = false;
						$structure['scheduleSection']['properties']['datesPreview']['hiddenByDefault'] = false;
						break;
					case '7':
						// custom
						$structure['scheduleSection']['properties']['frequencySection']['hiddenByDefault'] = false;
						if ($this->recurrenceFrequency == '2') {
							$structure['scheduleSection']['properties']['weeklySection']['hiddenByDefault'] = false;
						} else if ($this->recurrenceFrequency == '3') {
							$structure['scheduleSection']['properties']['monthlySection']['hiddenByDefault'] = false;
						}
						break;
				}
				switch ($this->monthlyOption) {
					case '1':
						$structure['scheduleSection']['properties']['monthlySection']['properties']['weekNumber']['hiddenByDefault'] = false;
						$structure['scheduleSection']['properties']['monthlySection']['properties']['monthDay']['hiddenByDefault'] = false;
						$structure['scheduleSection']['properties']['monthlySection']['properties']['monthDate']['hiddenByDefault'] = true;
						$structure['scheduleSection']['properties']['monthlySection']['properties']['monthOffset']['hiddenByDefault'] = false;
						break;
					case '2':
						$structure['scheduleSection']['properties']['monthlySection']['properties']['weekNumber']['hiddenByDefault'] = true;
						$structure['scheduleSection']['properties']['monthlySection']['properties']['monthDay']['hiddenByDefault'] = true;
						$structure['scheduleSection']['properties']['monthlySection']['properties']['monthDate']['hiddenByDefault'] = false;
						$structure['scheduleSection']['properties']['monthlySection']['properties']['monthOffset']['hiddenByDefault'] = true;
				}
				switch ($this->endOption) {
					case '1':
						$structure['scheduleSection']['properties']['repeatEndsSection']['properties']['recurrenceEnd']['hiddenByDefault'] = false;
						$structure['scheduleSection']['properties']['repeatEndsSection']['properties']['recurrenceCount']['hiddenByDefault'] = true;
						break;
					case '2':
						$structure['scheduleSection']['properties']['repeatEndsSection']['properties']['recurrenceEnd']['hiddenByDefault'] = true;
						$structure['scheduleSection']['properties']['repeatEndsSection']['properties']['recurrenceCount']['hiddenByDefault'] = false;
				}
			}
		}
		if ($this->locationId) {
			$structure['sublocationId']['values'] = Location::getEventSublocations($this->locationId);
			$structure['sublocationId']['hiddenByDefault'] = false;
		}
		$this->dateUpdated = time();
		return $structure;
	}
}
